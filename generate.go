/*
 * Copyright 2020 Torben Schinke
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sqlm

import (
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var commentsRegex = regexp.MustCompile("(-- .*)|(\\\\*.*\\*\\/)")

type Config struct {
	Version  string    `json:"version"`
	Packages []Package `json:"packages"`
}

type Package struct {
	Group   string `json:"group"`
	Path    string `json:"path"`
	PkgName string `json:"pkgname"`
	Schema  string `json:"schema"`
}

type migrationGroup struct {
	file     string
	config   Config
	dialects []dialect
}

type dialect struct {
	migrations []Migration
	pkg        Package
}

func Must(err error) {
	if err != nil {
		panic(err)
	}
}

func GenerateAll(dir string) error {
	if !strings.HasPrefix(dir, string(os.PathSeparator)) {
		absDir, err := os.Getwd()
		if err != nil {
			return err
		}
		dir = filepath.Join(absDir, dir)
	}

	fmt.Printf("scanning %s\n", dir)

	configs, err := scan(dir)
	if err != nil {
		return err
	}

	for _, cfg := range configs {
		for _, dlc := range cfg.dialects {
			if err := writeDialectMigration(cfg, dlc); err != nil {
				return err
			}
		}
	}

	return nil
}

func writeDialectMigration(cfg migrationGroup, dlc dialect) error {
	targetFile := filepath.Join(filepath.Dir(cfg.file), dlc.pkg.Path, "migrations.go")
	w := newWriter()
	w.Printf("// Code generated by sqlm. DO NOT EDIT.\n\n")
	w.Printf("package %s\n\n", dlc.pkg.PkgName)
	w.Printf(`
		type Migration = struct{
				Group      string
				Version    int64
				Statements []string
				ScriptName string
		}
    `)
	w.Printf("var Migrations = []Migration{\n")
	for _, migration := range dlc.migrations {
		w.Printf("{\n")
		w.Printf("Group:\"%s\",\n", migration.Group)
		w.Printf("Version:%d,\n", migration.Version)
		w.Printf("Statements:[]string{\n")
		for _, stmt := range migration.Statements {
			escpaped := strings.ReplaceAll(stmt, "\"", `\"`)
			w.Printf("\"%s\",\n", escpaped)
		}
		w.Printf("},\n")
		w.Printf("ScriptName:\"%s\",\n", migration.ScriptName)
		w.Printf("},\n")
	}
	w.Printf("}\n")

	formatted, err := format.Source([]byte(w.String()))
	if err != nil {
		fmt.Printf(w.String())
		return err
	}

	if err := ioutil.WriteFile(targetFile, formatted, os.ModePerm); err != nil {
		return err
	}
	return nil
}
